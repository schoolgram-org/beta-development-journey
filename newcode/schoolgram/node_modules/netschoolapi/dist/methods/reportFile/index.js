"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTaskId = getTaskId;
exports.default = reportFile;
const checks_1 = require("../../utils/checks");
const legacy_1 = __importDefault(require("./legacy"));
//? Функции помощники
/**
 * Формируем задачу
 * @param client клиент
 * @param url ссылка для запроса
 * @param params параметры запроса
 * @param filters фильтры запроса
 * @returns номер задачи
 */
function getTaskId(client, url, params, filters) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield client
            .post(url, {
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ params, selectedData: filters }),
        })
            .then((res) => res.json())
            .then(({ taskId }) => taskId);
    });
}
/**
 * Форматируем сообщение для WebSocket (с блядскими символами)
 * @param message сообщение (объект)
 * @param send нужно ли преобразовать в JSON
 * @returns сообщение (строка или буфер)
 */
function formatMsg(message, send = false) {
    if (send)
        return Buffer.from(JSON.stringify(message) + "");
    else
        return JSON.parse(message.toString().replace("", ""));
}
/**
 * Форматируем сообщение
 * @param msg сообщение от сервера
 */
function messageHandler(msg) {
    var _a;
    // Обработка сообщения
    const data = {
        error: undefined,
        fileCode: undefined,
    };
    // Если отчет готов
    if ("type" in msg && msg.type === 1 && msg.target === "complete") {
        data.fileCode = (_a = msg.arguments.find((arg) => {
            const keys = Object.keys(arg);
            return keys.includes("taskId") && keys.includes("data");
        })) === null || _a === void 0 ? void 0 : _a.data;
    }
    // Если произошла ошибка
    if ("error" in msg)
        data.error = msg.error;
    return data;
}
/**
 * Получение отчета с помощью Web Sockets
 * @param client клиент
 * @param context контекст
 * @param params параметры запроса
 * @param taskId номер задачи
 * @param timeout время ожидания ответа
 * @returns идентификатор отчета
 */
function webSocketsConnection(client, at, taskId, timeout) {
    return __awaiter(this, void 0, void 0, function* () {
        // Создаем WebSocket
        const ws = client.ws("queueHub", { params: { at } });
        // Обрабатывает сообщения
        return new Promise((resolve, reject) => {
            let fileCode;
            let timeoutId = 0;
            // Открываем соединение
            ws.once("open", () => __awaiter(this, void 0, void 0, function* () {
                // Устанавливаем тайм-аут
                if (timeout > 0)
                    timeoutId = setTimeout(() => ws.close(4010), timeout);
                // Открываем соединение
                ws.send(formatMsg({ protocol: "json", version: 1 }, true));
                // Уведомляем сервер о задаче
                ws.send(formatMsg({
                    arguments: [taskId, "report-v2"],
                    invocationId: "0",
                    target: "startTask",
                    type: 1,
                }, true));
            }));
            // Слушаем сообщения
            ws.on("message", (msg) => {
                // Пытаемся преобразовать сообщение в JSON
                let data;
                try {
                    data = messageHandler(formatMsg(msg));
                }
                catch (e) {
                    return;
                }
                // Обрабатываем ошибку
                if (data.error) {
                    console.error(data.error);
                    ws.close(4003, data.error);
                }
                // Обрабатываем
                if (data.fileCode) {
                    fileCode = data.fileCode;
                    ws.close(4000);
                }
            });
            // Обрабатываем ошибки соединения
            ws.once("error", (err) => ws.close(4002, err.message));
            // Закрываем соединение
            ws.once("close", (code, message) => __awaiter(this, void 0, void 0, function* () {
                clearTimeout(timeoutId);
                switch (code) {
                    // Если соединение закрыто успешно
                    case 1000:
                    case 4000:
                        if (!fileCode)
                            return reject(new Error("Server didn't respond"));
                        resolve(fileCode);
                        break;
                    // Если произошла ошибка инициализации
                    case 4001:
                        reject(new Error("Error during initialization"));
                        break;
                    // Если произошла ошибка с соединением
                    case 4002:
                        reject(new Error("Error in socket.\nError: " + message));
                        break;
                    // Если произошла ошибка с задачей
                    case 4003:
                        reject(new Error("Error in task.\nError: " + message));
                        break;
                    // Если вышло время ожидания
                    case 4010:
                        reject(new Error("Response time expired"));
                        break;
                    // Неизвестная ошибка
                    default:
                        reject(new Error("Unknown error.\nError: " + message));
                }
            }));
        });
    });
}
function reportFile(credentials) {
    return __awaiter(this, void 0, void 0, function* () {
        const { url, filters, yearId, timeout = 6e4, transport } = credentials;
        const { client, session, context } = yield checks_1.sessionValid.call(this);
        // Параметры запроса
        const params = [
            { name: "DATEFORMAT", value: context.server.dateFormat },
            {
                name: "SCHOOLYEARID",
                value: (yearId ? yearId : context.year.id).toString(),
            },
            { name: "SERVERTIMEZONE", value: 3 },
            { name: "FULLSCHOOLNAME", value: context.school.fullName },
        ];
        // Получаем идентификатор отчета
        let fileCode;
        // Если версия сервера меньше
        if (context.compareServerVersion("5.29.0.0") == -1) {
            fileCode = yield legacy_1.default.call(this, params, credentials);
        }
        // Если версия сервера больше или равна
        else {
            // Получаем идентификатор задачи
            const taskId = yield getTaskId(client, url, params, filters);
            // Получаем идентификатор отчета
            fileCode = yield webSocketsConnection(client, session.accessToken, taskId, timeout);
        }
        // Возвращаем отчет
        if (!fileCode)
            throw new Error("Server didn't respond");
        return (yield client.get("files/" + fileCode)).text();
    });
}
//# sourceMappingURL=index.js.map