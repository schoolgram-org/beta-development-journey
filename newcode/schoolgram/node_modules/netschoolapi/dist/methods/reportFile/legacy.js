"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = getFileCode;
const Client_1 = __importDefault(require("../../classes/Client"));
const checks_1 = require("../../utils/checks");
const index_1 = require("./index");
//? Функции помощники
/**
 * Получаем токен соединения
 * @param client клиент
 * @param params параметры для запроса
 */
function negotiate(client, params) {
    return __awaiter(this, void 0, void 0, function* () {
        return client
            .get("signalr/negotiate", { params })
            .then((res) => res.json());
    });
}
/**
 * Форматируем сообщение
 * @param msg сообщение от сервера
 */
function messageHandler(msg) {
    var _a, _b;
    const { C: messageId, M } = msg;
    let error = (_a = M.find((m) => m.M === "error")) === null || _a === void 0 ? void 0 : _a.A[0].Details;
    let fileCode = (_b = M.find((m) => m.M === "complete")) === null || _b === void 0 ? void 0 : _b.A[0].Data;
    return { error, fileCode, messageId };
}
/**
 * Уведомляем сервер о открытии соединения
 * @param client клиент
 * @param params параметры для запроса
 */
function startConnection(client, params) {
    return __awaiter(this, void 0, void 0, function* () {
        return client
            .get("signalr/start", { params })
            .then((res) => res.json())
            .then(({ Response }) => {
            if (Response !== "started")
                throw new Error("Соединение не удалось запустить, причина в том: " + Response);
            else
                return true;
        });
    });
}
/**
 * Получение отчета с помощью Web Sockets
 * @param client клиент
 * @param context контекст
 * @param params параметры запроса
 * @param taskId номер задачи
 * @param timeout время ожидания ответа
 * @returns идентификатор отчета
 */
function webSocketsConnection(client, context, params, taskId, timeout) {
    return __awaiter(this, void 0, void 0, function* () {
        // Создаем WebSocket
        const ws = client.ws("signalr/connect", { params });
        // Обрабатывает сообщения
        return new Promise((resolve, reject) => {
            let fileCode;
            let timeoutId = 0;
            // Открываем соединение
            ws.once("open", () => __awaiter(this, void 0, void 0, function* () {
                // Открываем соединение
                yield startConnection(client, params).catch(() => ws.close(4001));
                // Устанавливаем тайм-аут
                if (timeout > 0)
                    timeoutId = setTimeout(() => ws.close(4010), timeout);
                // Уведомляем сервер о задаче
                const msg = [taskId];
                if (context.compareServerVersion("5.24.0.0") != -1)
                    msg.push("report-v2");
                ws.send(JSON.stringify({
                    I: 0,
                    H: "queuehub",
                    M: "StartTask",
                    A: msg,
                }));
            }));
            // Слушаем сообщения
            ws.on("message", (msg) => {
                // Пытаемся преобразовать сообщение в JSON
                let data;
                try {
                    data = messageHandler(JSON.parse(msg));
                }
                catch (e) {
                    return;
                }
                // Обрабатываем ошибку
                if (data.error) {
                    console.error(data.error);
                    ws.close(4003, data.error);
                }
                // Обрабатываем
                if (data.fileCode) {
                    fileCode = data.fileCode;
                    ws.close(4000);
                }
            });
            // Обрабатываем ошибки соединения
            ws.once("error", (err) => ws.close(4002, err.message));
            // Закрываем соединение
            ws.once("close", (code, message) => __awaiter(this, void 0, void 0, function* () {
                clearTimeout(timeoutId);
                yield client.post("signalr/abort", { params });
                switch (code) {
                    // Если соединение закрыто успешно
                    case 1000:
                    case 4000:
                        if (!fileCode)
                            return reject(new Error("Server didn't respond"));
                        resolve(fileCode);
                        break;
                    // Если произошла ошибка инициализации
                    case 4001:
                        reject(new Error("Error during initialization"));
                        break;
                    // Если произошла ошибка с соединением
                    case 4002:
                        reject(new Error("Error in socket.\nError: " + message));
                        break;
                    // Если произошла ошибка с задачей
                    case 4003:
                        reject(new Error("Error in task.\nError: " + message));
                        break;
                    // Если вышло время ожидания
                    case 4010:
                        reject(new Error("Response time expired"));
                        break;
                    // Неизвестная ошибка
                    default:
                        reject(new Error("Unknown error.\nError: " + message));
                }
            }));
        });
    });
}
/**
 * Получение отчета с помощью Long Polling
 * @param client клиент
 * @param context контекст
 * @param params параметры запроса
 * @param taskId номер задачи
 * @param timeout время ожидания ответа
 * @returns идентификатор отчета
 */
function longPollingConnection(client, context, params, taskId, timeout) {
    return __awaiter(this, void 0, void 0, function* () {
        // Создаем соединение
        let messageId = yield client
            .post("signalr/connect", { params })
            .then((res) => res.json())
            .then(({ C }) => C);
        // Открываем соединение
        let fileCode;
        let timeoutId = 0;
        let timeoutIsOut = false;
        yield startConnection(client, params);
        // Устанавливаем тайм-аут
        if (timeout > 0)
            timeoutId = setTimeout(() => (timeoutIsOut = true), timeout);
        // Уведомляем сервер о задаче
        const msg = [taskId];
        if (context.compareServerVersion("5.24.0.0") != -1)
            msg.push("report-v2");
        yield client.post("signalr/send", {
            params,
            headers: {
                "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
            },
            body: "data=" +
                JSON.stringify({
                    I: 0,
                    H: "queuehub",
                    M: "StartTask",
                    A: msg,
                }),
        });
        // Получаем сообщения
        while (!timeoutIsOut && !fileCode) {
            // Получаем сообщение
            let data = yield client
                .post("signalr/poll", Object.assign({ params }, Client_1.default.formData({ messageId })))
                .then((res) => res.json())
                .then(messageHandler);
            messageId = data.messageId;
            // Обрабатываем ошибку
            if (data.error) {
                console.error(data.error);
                throw new Error("Error in task.\nError: " + data.error);
            }
            // Обрабатываем идентификатор отчета
            if (data.fileCode)
                fileCode = data.fileCode;
        }
        if (timeoutIsOut)
            throw new Error("Response time expired");
        if (!fileCode)
            throw new Error("Server didn't respond");
        clearTimeout(timeoutId);
        return fileCode;
    });
}
function getFileCode(params, credentials) {
    return __awaiter(this, void 0, void 0, function* () {
        const { url, filters, timeout = 6e4, transport } = credentials;
        const { client, session, context } = yield checks_1.sessionValid.call(this);
        // Данные для запроса
        const query = {
            _: session.ver,
            at: session.accessToken,
            transport: "webSockets",
            clientProtocol: 1.5,
            connectionData: '[{"name":"queuehub"}]',
        };
        // Получаем токен подключения
        const { ConnectionId, ConnectionToken } = yield negotiate(client, query);
        query.tid = ConnectionId[0];
        query.connectionToken = ConnectionToken;
        // Получаем номер задачи
        const taskId = yield (0, index_1.getTaskId)(client, url, params, filters);
        // Получаем идентификатор отчета
        let fileCode;
        if (transport == 0 ||
            (!transport && context.compareServerVersion("5.24.0.0") == -1)) {
            query.transport = "webSockets";
            fileCode = yield webSocketsConnection(client, context, query, taskId, timeout);
        }
        else if (transport == 1 ||
            (!transport && context.compareServerVersion("5.24.0.0") > -1)) {
            query.transport = "longPolling";
            fileCode = yield longPollingConnection(client, context, query, taskId, timeout);
        }
        return fileCode;
    });
}
//# sourceMappingURL=legacy.js.map