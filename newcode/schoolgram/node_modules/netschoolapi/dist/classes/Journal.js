"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const dateNum_1 = require("../utils/dateNum");
const parseHtml_1 = require("../utils/parseHtml");
//? Константы
// Селекторы промежутков
const RANGE_SELECTOR = "table td:nth-child(2) > span:nth-child(5)";
const RANGE_SELECTOR_V2 = "table td:nth-child(2) > span:nth-child(7)";
// Селектор дней
const DAYS_SELECTOR = "table.table-print tr:nth-child(2) > th";
// Селектор месяцев
const MONTHS_SELECTOR = "table.table-print tr:nth-child(1) > th[colspan]";
// Расшифровка названия месяцев в числа (разные года)
const MONTH_NUMBERS = {
    Сентябрь: 8,
    Октябрь: 9,
    Ноябрь: 10,
    Декабрь: 11,
    Январь: 12,
    Февраль: 13,
    Март: 14,
    Апрель: 15,
    Май: 16,
    Июнь: 17,
    Июль: 18,
    Август: 19,
};
// Расшифровка названия месяцев в числа (одинаковые года года)
const MONTH_NUMBERS_SY = {
    Сентябрь: 8,
    Октябрь: 9,
    Ноябрь: 10,
    Декабрь: 11,
    Январь: 0,
    Февраль: 1,
    Март: 2,
    Апрель: 3,
    Май: 4,
    Июнь: 5,
    Июль: 6,
    Август: 7,
};
//? Функции помощники
/**
 * Возвращает id четверти по дате
 * @param terms массив четвертей
 * @param date дата
 * @returns id четверти
 */
function termByDate(terms, date) {
    var _a, _b;
    return ((_b = (_a = terms.find((term) => term.id != -1 && +term.start <= +date && +date <= +term.end)) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : -1);
}
/**
 * Сопоставляем оценки с четвертями
 * @param terms массив четвертей
 * @param termTds массив с названиями четвертей
 * @param marksTds массив с оценками четвертей
 */
function totalMarksFormat(terms, termTds, marksTds) {
    var _a, _b;
    // Сопоставляем оценки с четвертями
    const totalMarks = [];
    const middleMarks = [];
    marksTds.forEach((mark, index) => {
        var _a, _b;
        // Получаем id четверти
        const tdName = termTds[index];
        const termId = (_b = (_a = terms.find((t) => tdName.includes(t.name))) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : -1;
        // Если это итоговая оценка за выбранный период
        if (tdName.includes("Итог") && mark)
            totalMarks.push({ mark, termId });
        // Если это средняя оценка за выбранный период
        if (tdName.includes("Средн") && mark)
            middleMarks.push({ mark, termId });
    });
    // Получаем среднюю оценку за выбранный период
    const periodMiddleMark = (_b = (_a = middleMarks[middleMarks.length - 1]) === null || _a === void 0 ? void 0 : _a.mark) !== null && _b !== void 0 ? _b : 0;
    return {
        totalMarks,
        middleMarks,
        periodMiddleMark,
        // TODO: удалить в следующих версиях
        middleMark: periodMiddleMark,
    };
}
/**
 * Парсим данные из файла отчета
 * @param html отчет в формате HTML
 * @param start дата начала отчета
 * @param end дата окончания отчета
 * @returns массив дат
 */
function parseDates(html, start, end) {
    const isSameYear = start.getFullYear() === end.getFullYear();
    // Получаем дни
    const days = Array.from((0, parseHtml_1.queryAll)(html, DAYS_SELECTOR), (th) => +th.structuredText);
    // Получаем месяца и его длину
    const months = Array.from((0, parseHtml_1.queryAll)(html, MONTHS_SELECTOR), (th) => {
        var _a;
        return ({
            length: +((_a = th.getAttribute("colspan")) !== null && _a !== void 0 ? _a : ""),
            number: !isSameYear
                ? MONTH_NUMBERS[th.structuredText]
                : MONTH_NUMBERS_SY[th.structuredText],
        });
    });
    // Форматируем даты
    const result = [];
    months.forEach(({ number, length }) => {
        const resultLength = result.length;
        for (let i = resultLength; i < resultLength + length; i++) {
            const date = new Date(start);
            date.setDate(days[i]);
            date.setMonth(number);
            result.push(date);
        }
    });
    return result;
}
class Journal {
    constructor(credentials) {
        var _a, _b;
        this.raw = credentials.htmlText;
        this._terms = credentials.terms;
        this._subjects = credentials.subjects;
        const [start = "", end = ""] = (_b = (_a = (0, parseHtml_1.query)(this.raw, !this._hasTerms ? RANGE_SELECTOR : RANGE_SELECTOR_V2)) === null || _a === void 0 ? void 0 : _a.structuredText.match(/((\d{1,2}\.){2}\d{2})/g)) !== null && _b !== void 0 ? _b : [];
        this.range = { start: (0, dateNum_1.str2date)(start), end: (0, dateNum_1.str2date)(end) };
    }
    /** Проверяет наличия деления на четверти */
    get _hasTerms() {
        return this._terms.length > 0;
    }
    /** Получаем распарсенные оценки по предметам */
    get subjects() {
        // Парсим даты
        const dates = parseDates(this.raw, this.range.start, this.range.end);
        // Получаем доступ к таблице
        const trs = (0, parseHtml_1.table)({
            html: this.raw,
            query: ".table-print",
            removeHeaders: false,
        });
        // Получаем название четвертей
        const termTds = Array.from(trs[0].querySelectorAll("th[rowspan]"), (th) => th.text.trim());
        // Удаляем лишнее
        trs.splice(0, 2);
        termTds.shift();
        return trs.map((tr) => {
            var _a, _b, _c;
            // Получаем название предмета
            const nameTd = tr.querySelector("td:nth-child(1)");
            const name = (_a = nameTd === null || nameTd === void 0 ? void 0 : nameTd.text.trim()) !== null && _a !== void 0 ? _a : "";
            // Получаем средние оценки и итоговые
            const marksTds = Array.from(tr.querySelectorAll("td.cell-num-2"), (td) => +td.text.trim().replace(",", "."));
            // Получаем данные ячеек за период
            const periodTds = Array.from(tr.querySelectorAll(":not([class])"), (td) => td.text.trim());
            // Парсим данные ячеек за период
            const marks = [];
            const dotList = [];
            const missedList = [];
            periodTds.forEach((content, i) => {
                var _a, _b, _c;
                const date = dates[i];
                if (!content)
                    return;
                (_a = content.match(/\d/g)) === null || _a === void 0 ? void 0 : _a.forEach((str) => marks.push({
                    mark: +str,
                    date,
                    termId: termByDate(this._terms, date),
                }));
                (_b = content.match(/\./g)) === null || _b === void 0 ? void 0 : _b.forEach(() => dotList.push({
                    date,
                    termId: termByDate(this._terms, date),
                }));
                (_c = content.match(/[А-Яа-я]+/g)) === null || _c === void 0 ? void 0 : _c.forEach((type) => missedList.push({
                    type,
                    date,
                    termId: termByDate(this._terms, date),
                }));
            });
            // Возвращаем данные предмета
            return Object.assign({ id: (_c = (_b = this._subjects.find((s) => s.name === name)) === null || _b === void 0 ? void 0 : _b.id) !== null && _c !== void 0 ? _c : -1, name,
                marks,
                dotList,
                missedList }, totalMarksFormat(this._terms, termTds, marksTds));
        });
    }
    toJSON() {
        return {
            raw: this.raw,
            range: {
                start: (0, dateNum_1.date2JSON)(this.range.start),
                end: (0, dateNum_1.date2JSON)(this.range.end),
            },
            subjects: this.subjects.map((s) => (Object.assign(Object.assign({}, s), { marks: s.marks.map((m) => (Object.assign(Object.assign({}, m), { date: (0, dateNum_1.date2JSON)(m.date) }))), dotList: s.dotList.map((d) => (Object.assign(Object.assign({}, d), { date: (0, dateNum_1.date2JSON)(d.date) }))), missedList: s.missedList.map((m) => (Object.assign(Object.assign({}, m), { date: (0, dateNum_1.date2JSON)(m.date) }))) }))),
        };
    }
}
exports.default = Journal;
//# sourceMappingURL=Journal.js.map